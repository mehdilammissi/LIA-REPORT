/*
 * Project: IR Controlled Robot - Speed Scaling for Turns
 * Goal: Ensure that the speed for turning (left/right) scales with the currentSpeed
 * set by the speed up/down buttons (BTN_OK/BTN_STOP).
 *
 * WIRING:
 * Motor Driver (L298N/similar):
 * PWMA -> 5, AIN1 -> 7
 * PWMB -> 6, BIN1 -> 8
 * STBY -> 3
 * IR Receiver -> 9
 */
#include <Servo.h>
#include <IRremote.h>
#include <Adafruit_NeoPixel.h>


// LED CONFIGURATION
#define LED_PIN 4
#define NUM_LEDS 1
Adafruit_NeoPixel led(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

void setLED(uint8_t r, uint8_t g, uint8_t b) {
  led.setPixelColor(0, led.Color(r, g, b));
  led.show();
}

// Mode colors ONLY
void ledMode1() { setLED(255, 0, 0); }     // COLOR RED
void ledMode2() { setLED(0, 0, 255); }     // COLOR BLUE
void ledMode3() { setLED(255, 255, 0); }   // COLOR YELLOW
void ledMode4() { setLED(128, 0, 128); }  // COLOR PURPLE

// =======================
// IR CONFIG
// =======================
const int IR_RECEIVE_PIN = 9;
unsigned long lastCode = 0;
unsigned long lastPressTime = 0;
const int RELEASE_TIMEOUT = 400; // Time (ms) after which motors stop if no button is held
int mode = 1;

// IR BUTTONS
#define BTN_UP     0xB946FF00
#define BTN_LEFT   0xBB44FF00
#define BTN_RIGHT  0xBC43FF00
#define BTN_DOWN   0xEA15FF00
#define BTN_OK     0xBF40FF00    // USED FOR SPEED UP
// *** UPDATED BTN_STOP with confirmed '5' button code (0xE718FF00) ***
#define BTN_STOP   0xE718FF00    // Confirmed code for '5' button / SPEED DOWN
#define BTN_MODE1  0xE916FF00
#define BTN_MODE2  0xE619FF00
#define BTN_MODE3  0xF20DFF00
#define BTN_MODE4  0xF30CFF00

// =======================
// MOTOR CONFIG
// =======================
int PWMA = 5, AIN1 = 7;
int PWMB = 6, BIN1 = 8;
int STBY = 3;

// SPEED VARIABLES
int currentSpeed = 100; // Starting speed for UP/DOWN movement
const int SPEED_STEP = 20; // Changed step size for noticeable change
const int MAX_SPEED = 255;
const int MIN_SPEED = 0;

// Motor direction state, used to maintain speed when accelerating/decelerating
unsigned long lastDirectionCode = 0;


// =======================
// ULTRASONIC/SERVO CONFIG
// =======================
Servo myservo;
const int Trig = 13;
const int Echo = 12;

// =======================
// FORWARD DECLARATIONS
// =======================
float DistanceMeter();
void modeAnalogSensor();
void modeUltrasonic();
void modeVictoryLap();
void forward(int s);
void backward(int s);
void left(int s);
void right(int s);
void stopMotors();


// =======================
// SETUP
// =======================
void setup() {
  Serial.begin(9600);
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
  led.begin();
  led.show();
  ledMode1();    // Default boot color

  // Setup motor pins
  pinMode(PWMA, OUTPUT); 
  pinMode(AIN1, OUTPUT);
  pinMode(PWMB, OUTPUT); 
  pinMode(BIN1, OUTPUT);
  pinMode(STBY, OUTPUT); 
  digitalWrite(STBY, HIGH); // Enable the motor driver

  pinMode(Trig, OUTPUT); 
  pinMode(Echo, INPUT);

  myservo.attach(10);
  Serial.println("System Booted - Ready");
}


// LOOP

void loop() {

  // ==== IR READ ====
  if (IrReceiver.decode()) {
    unsigned long code = IrReceiver.decodedIRData.decodedRawData;
    // Only capture codes that are not repeat codes (0x0)
    if (code != 0x0) lastCode = code;
    lastPressTime = millis();

    // ===== MODE SWITCHING (LED SET HERE ONLY) =====
    if (lastCode == BTN_MODE1) { mode = 1; ledMode1(); Serial.println("MODE 1"); lastDirectionCode = 0;}
    if (lastCode == BTN_MODE2) { mode = 2; ledMode2(); Serial.println("MODE 2"); lastDirectionCode = 0;}
    if (lastCode == BTN_MODE3) { mode = 3; ledMode3(); Serial.println("MODE 3"); lastDirectionCode = 0;}
    if (lastCode == BTN_MODE4) { mode = 4; ledMode4(); Serial.println("MODE 4"); lastDirectionCode = 0;}

    IrReceiver.resume();
  }

  // ===== EXECUTE CURRENT MODE =====
  switch(mode) {
    case 1: modeIRControl(); break;
    case 2: modeAnalogSensor(); break;
    case 3: modeUltrasonic(); break;
    case 4: modeVictoryLap(); break;
  }
}


// =======================================================
// MODE 1 – IR REMOTE (SPEED CONTROL LOGIC)
// =======================================================
void modeIRControl() {
  
  // --- SPEED ADJUSTMENT ---
  if (lastCode == BTN_OK) {
    // Increase speed (Speed UP)
    currentSpeed = constrain(currentSpeed + SPEED_STEP, MIN_SPEED, MAX_SPEED);
    Serial.print("Speed UP | Current Speed = ");
    Serial.println(currentSpeed);
    lastCode = 0; // Clear code to prevent rapid speed change
  }
  
  if (lastCode == BTN_STOP) {
    // Decrease speed (Speed DOWN)
    currentSpeed = constrain(currentSpeed - SPEED_STEP, MIN_SPEED, MAX_SPEED);
    Serial.print("Speed DOWN | Current Speed = ");
    Serial.println(currentSpeed);
    lastCode = 0; // Clear code to prevent rapid speed change
  }
  // --- END SPEED ADJUSTMENT ---


  // --- DIRECTIONAL MOVEMENT ---
  
  // 1. If no button has been pressed for a while, stop and reset state
  if (millis() - lastPressTime > RELEASE_TIMEOUT) {
    stopMotors();
    lastDirectionCode = 0; 
    return;
  }

  // 2. Execute movement based on the last code received
  switch(lastCode) {
    case BTN_UP: 
      forward(currentSpeed); 
      lastDirectionCode = BTN_UP;
      break;
    case BTN_DOWN: 
      backward(currentSpeed); 
      lastDirectionCode = BTN_DOWN;
      break;
    case BTN_LEFT: 
      // *** CHANGE HERE: Use currentSpeed for turning ***
      left(currentSpeed); 
      lastDirectionCode = BTN_LEFT;
      break;
    case BTN_RIGHT: 
      // *** CHANGE HERE: Use currentSpeed for turning ***
      right(currentSpeed); 
      lastDirectionCode = BTN_RIGHT;
      break;
      
    // 3. If a speed button was pressed, or the last code was cleared, maintain last direction
    default:
      switch (lastDirectionCode) {
          case BTN_UP: forward(currentSpeed); break;
          case BTN_DOWN: backward(currentSpeed); break;
          default: stopMotors(); break;
      }
      break;
  }
}


// =======================================================
// MODE 2 – ANALOG SENSOR (Line Following/Obstacle Detection)
// =======================================================
void modeAnalogSensor() {

  float R = analogRead(A0);
  float M = analogRead(A1);
  float L = analogRead(A2);

  if (M > 1000) { stopMotors(); return; }
  if (L > 300) { left(50); return; }
  if (M > 300) { forward(50); return; } 
  if (R > 300) { right(50); return; }

  right(50); 
}


// =======================================================
// MODE 3 – ULTRASONIC AVOID
// =======================================================
void modeUltrasonic() {

  myservo.write(90);
  float forwardDistance = DistanceMeter();

  if (forwardDistance == 0 || forwardDistance >= 25) {
    forward(70);
    return;
  }

  stopMotors();
  delay(200);

  // LOOK LEFT
  myservo.write(180);
  delay(1000);
  float leftDistance = DistanceMeter();
  if (leftDistance == 0) leftDistance = 300; 

  // LOOK RIGHT
  myservo.write(0);
  delay(1000);
  float rightDistance = DistanceMeter();
  if (rightDistance == 0) rightDistance = 300;

  // Decision logic
  if (leftDistance > 25 && rightDistance <= 25) {
    left(70);
    delay(1000);
  } else if (rightDistance > 25 && leftDistance <= 25) {
    right(70);
    delay(1000);
  } else if (leftDistance > 25 && rightDistance > 25) {
    if (leftDistance > rightDistance) {
      left(70);
      delay(1000);
    } else {
      right(70);
      delay(1000);
    }
  } else {
    backward(70);
    delay(600);
    left(70);
    delay(1000);
  }
  
  stopMotors();
}


// =======================================================
// ULTRASONIC DISTANCE FUNCTION
// =======================================================
float DistanceMeter() {

  digitalWrite(Trig, LOW);
  delayMicroseconds(2);
  digitalWrite(Trig, HIGH);
  delayMicroseconds(10);
  digitalWrite(Trig, LOW);

  long duration = pulseIn(Echo, HIGH, 25000); 
  if (duration == 0) return 0;

  float distance = (duration * 0.0343) / 2.0;
  if (distance > 300) return 0; 

  return distance;
}

// =======================================================
// MODE 4 – VICTORY LAP RECTANGLE
// =======================================================
void modeVictoryLap() {
  forward(50); delay(12000);
  left(50); delay(600);

  forward(50); delay(5000);
  left(50); delay(600);

  forward(50); delay(12000);
  left(50); delay(600);

  forward(50); delay(5000);
  left(50); delay(600);

  left(70); delay(2000);
  stopMotors();
}

// =======================================================
// MOTOR FUNCTIONS
// =======================================================
void forward(int s)
{ digitalWrite(AIN1,HIGH); analogWrite(PWMA,s); digitalWrite(BIN1,HIGH); analogWrite(PWMB,s); }

void backward(int s)
{ digitalWrite(AIN1,LOW); analogWrite(PWMA,s); digitalWrite(BIN1,LOW); analogWrite(PWMB,s); }

void left(int s)
// Rotates left (Left wheel backward, Right wheel forward)
{ digitalWrite(AIN1,LOW); analogWrite(PWMA,s); digitalWrite(BIN1,HIGH); analogWrite(PWMB,s); }

void right(int s)
// Rotates right (Left wheel forward, Right wheel backward)
{ digitalWrite(AIN1,HIGH); analogWrite(PWMA,s); digitalWrite(BIN1,LOW); analogWrite(PWMB,s); }

void stopMotors()
{ analogWrite(PWMA,0); analogWrite(PWMB,0); }
