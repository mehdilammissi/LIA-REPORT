/*
 * Project: IR Controlled Robot - Speed Modification
 * Goal: Modify the motor control logic so that the speed for both forward 
 * and backward movement is independently increased/decreased using specific 
 * IR buttons (BTN_OK to speed up, BTN_STOP to slow down).
 *
 * NOTE: The motor speed 'y' will be maintained during UP/DOWN commands.
 */
#include <Servo.h>
#include <IRremote.h>
#include <Adafruit_NeoPixel.h>


// LED CONFIGURATION
#define LED_PIN 4
#define NUM_LEDS 1
Adafruit_NeoPixel led(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

void setLED(uint8_t r, uint8_t g, uint8_t b) {
  led.setPixelColor(0, led.Color(r, g, b));
  led.show();
}

// Mode colors ONLY
void ledMode1() { setLED(255, 0, 0); }    // COLOR RED
void ledMode2() { setLED(0, 0, 255); }    // COLOR BLUE
void ledMode3() { setLED(255, 255, 0); }    // COLOR YELLOW
void ledMode4() { setLED(128, 0, 128); }  // COLOR PURPLE

// =======================
// IR CONFIG
// =======================
const int IR_RECEIVE_PIN = 9;
unsigned long lastCode = 0;
unsigned long lastPressTime = 0;
const int RELEASE_TIMEOUT = 400;
int mode = 1;

// IR BUTTONS
#define BTN_UP     0xB946FF00
#define BTN_LEFT   0xBB44FF00
#define BTN_RIGHT  0xBC43FF00
#define BTN_DOWN   0xEA15FF00
#define BTN_OK     0xBF40FF00   // USED FOR SPEED UP
#define BTN_STOP   0x9867FF00   // DUMMY CODE FOR '0' BUTTON / SPEED DOWN
#define BTN_MODE1  0xE916FF00
#define BTN_MODE2  0xE619FF00
#define BTN_MODE3  0xF20DFF00
#define BTN_MODE4  0xF30CFF00

// =======================
// MOTOR CONFIG
// =======================
int PWMA = 5, AIN1 = 7;
int PWMB = 6, BIN1 = 8;
int STBY = 3;

// SPEED VARIABLES
int currentSpeed = 100; // Starting speed for UP/DOWN movement
const int SPEED_STEP = 20; // Changed step size for noticeable change
const int MAX_SPEED = 255;
const int MIN_SPEED = 0;

// Motor direction state, used to maintain speed when accelerating/decelerating
unsigned long lastDirectionCode = 0;


// =======================
// ULTRASONIC CONFIG
// =======================
Servo myservo;
const int Trig = 13;
const int Echo = 12;

// Timer for ultrasonic checks (if needed)
unsigned long ultrasonicTimer = 0;
const unsigned long ULTRASONIC_INTERVAL = 50;

// =======================
// SETUP
// =======================
void setup() {
  Serial.begin(9600);
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);
  led.begin();
  led.show();
  ledMode1();  // Default boot color

  pinMode(PWMA, OUTPUT); 
  pinMode(AIN1, OUTPUT);
  pinMode(PWMB, OUTPUT); 
  pinMode(BIN1, OUTPUT);
  pinMode(STBY, OUTPUT); 
  digitalWrite(STBY, HIGH);

  pinMode(Trig, OUTPUT); 
  pinMode(Echo, INPUT);

  myservo.attach(10);
  Serial.println("System Booted - Ready");
}


// LOOP

void loop() {

  // ==== IR READ ====
  if (IrReceiver.decode()) {
    unsigned long code = IrReceiver.decodedIRData.decodedRawData;
    if (code != 0x0) lastCode = code;
    lastPressTime = millis();

    // ===== MODE SWITCHING (LED SET HERE ONLY) =====
    if (lastCode == BTN_MODE1) { mode = 1; ledMode1(); Serial.println("MODE 1"); }
    if (lastCode == BTN_MODE2) { mode = 2; ledMode2(); Serial.println("MODE 2"); }
    if (lastCode == BTN_MODE3) { mode = 3; ledMode3(); Serial.println("MODE 3"); }
    if (lastCode == BTN_MODE4) { mode = 4; ledMode4(); Serial.println("MODE 4"); }

    IrReceiver.resume();
  }

  // ===== EXECUTE CURRENT MODE =====
  switch(mode) {
    case 1: modeIRControl(); break;
    case 2: modeAnalogSensor(); break;
    case 3: modeUltrasonic(); break;
    case 4: modeVictoryLap(); break;
  }
}


// MODE 1 – IR REMOTE (REVISED)

void modeIRControl() {
  
  // --- SPEED ADJUSTMENT ---
  if (lastCode == BTN_OK) {
    // Increase speed
    currentSpeed += SPEED_STEP;
    if (currentSpeed > MAX_SPEED) currentSpeed = MAX_SPEED;
    Serial.print("Speed UP | Current Speed = ");
    Serial.println(currentSpeed);
    lastCode = 0; // Clear code to prevent rapid speed change
  }
  
  if (lastCode == BTN_STOP) {
    // Decrease speed
    currentSpeed -= SPEED_STEP;
    if (currentSpeed < MIN_SPEED) currentSpeed = MIN_SPEED;
    Serial.print("Speed DOWN | Current Speed = ");
    Serial.println(currentSpeed);
    lastCode = 0; // Clear code to prevent rapid speed change
  }
  // --- END SPEED ADJUSTMENT ---


  // --- DIRECTIONAL MOVEMENT ---
  if (millis() - lastPressTime > RELEASE_TIMEOUT) {
    stopMotors();
    // Clear last direction code when stopped
    lastDirectionCode = 0; 
    return;
  }

  switch(lastCode) {
    case BTN_UP: 
      forward(currentSpeed); 
      lastDirectionCode = BTN_UP;
      break;
    case BTN_DOWN: 
      backward(currentSpeed); 
      lastDirectionCode = BTN_DOWN;
      break;
    case BTN_LEFT: 
      left(100); // Fixed speed for turns
      lastDirectionCode = BTN_LEFT;
      break;
    case BTN_RIGHT: 
      right(100); // Fixed speed for turns
      lastDirectionCode = BTN_RIGHT;
      break;
      
    // If a direction was pressed but we accelerated/decelerated, maintain direction
    default:
      switch (lastDirectionCode) {
          case BTN_UP: forward(currentSpeed); break;
          case BTN_DOWN: backward(currentSpeed); break;
          // Note: Left/Right typically should stop after RELEASE_TIMEOUT unless held
          default: stopMotors(); break;
      }
      break;
  }
}


// MODE 2 – ANALOG SENSOR (No changes required)

void modeAnalogSensor() {

  float R = analogRead(A0);
  float M = analogRead(A1);
  float L = analogRead(A2);

  if (M > 1000) { stopMotors(); return; }
  if (L > 300) { left(50); return; }
  if (M > 300) { forward(50); return; }
  if (R > 300) { right(50); return; }

  right(50);
}


// MODE 3 – ULTRASONIC AVOID (UPDATED) (No changes required)

void modeUltrasonic() {

  // Look forward
  myservo.write(90);
  float forwardDistance = DistanceMeter();

  if (forwardDistance == 0) {
    forward(70);
    return;
  }

  if (forwardDistance >= 25) {
    forward(70);
    return;
  }

  stopMotors();
  delay(200);

  // LOOK LEFT
  myservo.write(180);
  delay(400);
  float leftDistance = DistanceMeter();
  if (leftDistance == 0) leftDistance = 300;

  if (leftDistance > 25) {
    Serial.println("Turning LEFT...");
    left(70);
    delay(500);
    return;
  }

  // LOOK RIGHT
  myservo.write(0);
  delay(400);
  float rightDistance = DistanceMeter();
  if (rightDistance == 0) rightDistance = 300;

  Serial.print("Right distance: ");
  Serial.println(rightDistance);

  // RIGHT BLOCKED → BACKWARD + 180 TURN + FORWARD
  if (rightDistance < 25) {
    Serial.println("RIGHT BLOCKED → BACKWARD + 180 TURN");
    backward(70);
    delay(600);
    left(70);
    delay(1000);
    forward(70);
    delay(500);
    return;
  }

  // RIGHT SAFE → turn right normally
  if (rightDistance > 25) {
    Serial.println("Turning RIGHT...");
    right(70);
    delay(500);
    return;
  }

  stopMotors();
}


// ULTRASONIC DISTANCE FUNCTION (No changes required)

float DistanceMeter() {

  digitalWrite(Trig, LOW);
  delayMicroseconds(2);
  digitalWrite(Trig, HIGH);
  delayMicroseconds(10);
  digitalWrite(Trig, LOW);

  long duration = pulseIn(Echo, HIGH, 25000);
  if (duration == 0) return 0;

  float distance = (duration * 0.0343) / 2.0;
  if (distance > 300) return 0;

  return distance;
}

// MODE 4 – VICTORY LAP RECTANGLE (No changes required)

void modeVictoryLap() {
  // Uses fixed speeds, no changes needed for this mode
  forward(50); delay(12000);
  left(50); delay(600);

  forward(50); delay(5000);
  left(50); delay(600);

  forward(50); delay(12000);
  left(50); delay(600);

  forward(50); delay(5000);
  left(50); delay(600);

  // Celebration spin
  left(70); delay(2000);
  stopMotors();
}

// =======================
// MOTOR FUNCTIONS (No changes required)
// =======================
void forward(int s)
{ digitalWrite(AIN1,HIGH); analogWrite(PWMA,s); digitalWrite(BIN1,HIGH); analogWrite(PWMB,s); }

void backward(int s)
{ digitalWrite(AIN1,LOW); analogWrite(PWMA,s); digitalWrite(BIN1,LOW); analogWrite(PWMB,s); }

void left(int s)
{ digitalWrite(AIN1,HIGH); analogWrite(PWMA,s); digitalWrite(BIN1,LOW); analogWrite(PWMB,s); }

void right(int s)
{ digitalWrite(AIN1,LOW); analogWrite(PWMA,s); digitalWrite(BIN1,HIGH); analogWrite(PWMB,s); }

void stopMotors()
{ analogWrite(PWMA,0); analogWrite(PWMB,0); }
